---
title: 运行任务
description: 学习如何使用 Turborepo 运行任务，包括使用 package.json 脚本、全局 turbo 命令和过滤器
---

Turborepo 通过自动并行化和缓存任务来优化您仓库中的开发者工作流程。一旦任务在 [`turbo.json` 中注册](/crafting-your-repository/configuring-tasks)，您就拥有了在仓库中运行脚本的强大新工具集：

- [在 `package.json` 中使用 `scripts` 来运行经常需要的任务](#using-scripts-in-packagejson)
- [使用全局 `turbo` 快速按需运行自定义任务](#using-global-turbo)
- [按目录、包名、源代码控制变更等过滤任务](#using-filters)

通过 `turbo` 运行任务非常强大，因为您可以在开发和 CI 流水线中使用一个统一的模型来执行整个仓库的工作流程。

## 在 `package.json` 中使用 `scripts`

对于经常运行的任务，您可以将 `turbo` 命令直接写入根目录的 `package.json` 中。

```jsonc title="./package.json"
{
  "scripts": {
    "dev": "turbo run dev",
    "build": "turbo run build",
    "test": "turbo run test",
    "lint": "turbo run lint"
  }
}
```

::callout{type="info"}
`turbo` 是 `turbo run` 的别名 - 但我们建议在 `package.json` 和 CI 工作流程中使用 `turbo run`，以避免与将来可能添加的 `turbo` 子命令发生潜在冲突。
::

然后可以使用您的包管理器运行这些脚本。

::code-group

```bash [pnpm]
pnpm dev
```

```bash [yarn]
yarn dev
```

```bash [npm]
npm run dev
```

```bash [bun (Beta)]
bun run dev
```

::

::callout{type="warning"}
您只应该在根目录的 `package.json` 中编写 `turbo` 命令。在包的 `package.json` 中编写 `turbo` 命令可能会导致递归调用 `turbo`。
::

## 使用全局 `turbo`

[全局安装 `turbo`](/getting-started/installation#global-installation) 让您可以直接从终端运行命令。这改善了您的本地开发体验，因为它使您更容易在需要时运行确切需要的内容。

此外，全局 `turbo` 在您的 CI 流水线中很有用，让您可以最大程度地控制在流水线的每个点运行哪些确切的任务。

### 自动包作用域

当您在包的目录中时，`turbo` 会自动将命令作用域限定为该包的[包图](/core-concepts/package-and-task-graphs#package-graph)。这意味着您可以快速编写命令，而无需为包[编写过滤器](/api-reference/commands/run#--filter-string)。

```bash title="Terminal"
cd apps/docs
turbo build
```

在上面的示例中，`turbo build` 命令将使用在 `turbo.json` 中注册的 `build` 任务为 `docs` 包运行 `build` 任务。

::callout{type="info"}
[使用过滤器](#using-filters)将覆盖自动包作用域。
::

### 自定义行为

在 [`run` 子命令的文档](/api-reference/commands/run)中，您会找到许多有用的标志来定制 `turbo run` 的行为以满足您的需求。运行全局 `turbo` 时，您可以使用以下工作流程来提高速度：

- **最常用命令的变体**：`package.json` 中的 `build` 脚本在是 `turbo build` 时最有用 - 但您目前可能只对特定包感兴趣。您可以使用 `turbo build --filter=@repo/ui` 快速过滤您感兴趣的特定包。
- **一次性命令**：像 `turbo build --dry` 这样的命令不经常需要，所以您可能不会在 `package.json` 中为它创建脚本。相反，您可以在需要时直接在终端中运行它。
- **覆盖 `turbo.json` 配置**：一些 CLI 标志在 `turbo.json` 中有等效的配置，您可以覆盖它们。例如，您可能有一个配置为使用 [`"outputLogs": "full"` 在 `turbo.json`](/api-reference/configuration/configuring-turbo.json#outputlogs) 中的 `turbo build` 命令 - 但您目前只想看到错误。使用全局 `turbo`，您可以使用 `turbo lint --output-logs=errors-only` 来只显示错误。

## 运行多个任务

`turbo` 能够运行多个任务，尽可能并行化。

```bash title="Terminal"
turbo run build test lint check-types
```

此命令将运行所有任务，根据您的任务定义自动检测可以尽早运行脚本的位置。

::callout{type="info" title="任务顺序"}
`turbo test lint` 运行任务的方式与 `turbo lint test` 完全相同。

如果您想确保一个任务阻止另一个任务的执行，请在您的[任务配置](/crafting-your-repository/configuring-tasks#defining-tasks)中表达这种关系。
::

## 使用过滤器

虽然[缓存](/crafting-your-repository/running-tasks)通过永不重复相同工作来确保您保持快速，但您也可以过滤任务以仅运行[任务图](/core-concepts/package-and-task-graphs#task-graph)的子集。

在 [`--filter` API 参考](/api-reference/commands/run#--filter-string)中有许多过滤的高级用例，但下面讨论了最常见的用例。

### 按包过滤

按包过滤是一种简单的方法，只为您当前正在处理的包运行任务。

```bash title="Terminal"
turbo build --filter=@acme/web
```

::callout{type="info" title="版本 2.2.4+"}
您也可以在 CLI 命令中直接过滤到包的特定任务，而无需使用 `--filter`：

```bash title="Terminal"
# 为 `web` 包运行 `build` 任务
turbo run web#build

# 为 `web` 包运行 `build` 任务，为 `docs` 包运行 `lint` 任务
turbo run web#build docs#lint
```
::

### 按目录过滤

您的仓库可能有一个目录结构，其中相关的包被分组在一起。在这种情况下，您可以捕获该目录的 glob 模式来让 `turbo` 专注于这些包。

```bash title="Terminal"
turbo lint --filter="./packages/utilities/*"
```

### 过滤以包含依赖者

当您正在处理特定包时，您可能希望为该包及其依赖者运行任务。`...` 微语法在您对包进行更改并希望确保更改不会破坏其任何依赖者时很有用。

```bash title="Terminal"
turbo build --filter=...ui
```

### 过滤以包含依赖项

要将范围限制为包及其依赖项，请在包名后附加 `...`。这会为指定的包及其依赖的所有包运行任务。

```bash title="Terminal"
turbo dev --filter=web...
```

### 按源代码控制变更过滤

使用过滤器根据源代码控制中的变更运行任务是一种很好的方法，只为受您的变更影响的包运行任务。**源代码控制过滤器必须用 `[]` 包装**。

- **与上一次提交比较**：`turbo build --filter=[HEAD^1]`
- **与主分支比较**：`turbo build --filter=[main...my-feature]`
- **使用 SHA 比较特定提交**：`turbo build --filter=[a1b2c3d...e4f5g6h]`
- **使用分支名比较特定提交**：`turbo build --filter=[your-feature...my-feature]`

::callout{type="info"}
一般来说，您可以依靠缓存来保持仓库的快速。当您使用[远程缓存](/core-concepts/remote-caching)时，您可以指望为未更改的包命中缓存。
::

### 组合过滤器

为了更加精确，您可以组合过滤器来进一步细化进入[任务图](/core-concepts/package-and-task-graphs#task-graph)的入口点。

```bash title="Terminal"
turbo build --filter=...ui --filter={./packages/*} --filter=[HEAD^1]
```

多个过滤器作为**并集**组合，这意味着[任务图](/core-concepts/package-and-task-graphs#task-graph)将包含匹配任何过滤器的任务。有关过滤器高级用法的更多信息，请参阅 [`--filter` API 参考](/api-reference/commands/run#--filter-string)。

## 下一步

当您开始在仓库中运行任务时，您可能会开始注意到您的任务变得更快。接下来，您将探索[缓存](/crafting-your-repository/caching)以及 `turbo` 如何确保您永远不会重复相同的工作。
