---
title: watch
description: 基于代码更改重新运行仓库中的任务，支持依赖感知和持久任务处理
---

基于代码更改重新运行仓库中的任务。

```bash title="Terminal"
turbo watch [tasks]
```

`turbo watch` 具有依赖感知能力，意味着任务将按照[在 `turbo.json` 中配置的](/docs/reference/configuration)顺序重新运行。

如果未提供任务，`turbo` 将显示仓库中包可用的任务。

```bash title="Terminal"
turbo watch
```

## 将 `turbo watch` 与持久任务一起使用

持久任务标记为 [`"persistent": true`](/docs/reference/configuration#persistent)，意味着它们不会退出。因此，它们不能在任务图中被依赖。

这意味着在使用 `turbo watch` 时，持久任务将被忽略，工作方式与 [`turbo run`](/docs/reference/run) 相同，允许持久和非持久任务同时运行。

### 具有依赖感知的持久任务

当您的脚本具有内置监视器（如 `next dev`）能够检测依赖项中的更改时，您不需要使用 `turbo watch`。相反，使用脚本的内置监视器并使用 [`"persistent": true`](/docs/reference/configuration#persistent) 将任务标记为长时间运行。

### 不具有依赖感知的持久任务

一些工具不是 monorepo 友好的，不会热重载依赖项中的模块。在这些情况下，您应该将任务标记为 [`interruptible: true`](/docs/reference/configuration#interruptible)，以便 `turbo watch` 在检测到相关更改时重新启动任务。

## 限制

### 缓存

使用监视模式缓存任务目前是实验性的，在 `--experimental-write-cache` 标志下。

```bash title="Terminal"
turbo watch your-tasks --experimental-write-cache
```

### 任务输出

如果您有将文件写入源代码控制的任务，监视模式可能会无限循环运行。这是因为监视模式监视您的文件更改并将重新运行已更改包中的任务。如果任务创建了更改，那么这将再次触发任务。

监视模式有一些逻辑来防止使用文件哈希发生这种情况，但它并不是万无一失的。为了避免这个问题，我们建议从 git 中删除任何任务输出。
