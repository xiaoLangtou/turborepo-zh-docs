---
title: prune
description: 为目标包生成部分 monorepo，包含构建所需的内部包源代码、修剪的锁文件和根 package.json
---



为目标包生成部分 monorepo。输出将放置在名为 `out` 的目录中，包含以下内容：

- 构建目标所需的所有内部包的完整源代码。
- 包含构建目标所需的原始锁文件子集的修剪锁文件。
- 根 `package.json` 的副本。

```bash title="Terminal"
turbo prune [package]
```

### 示例

从具有以下结构的仓库开始：




```
├── package.json
├── pnpm-lock.yaml
├── apps/
│   ├── admin/
│   │   ├── package.json
│   │   ├── next-env.d.ts
│   │   ├── next.config.js
│   │   ├── src/
│   │   │   └── app/
│   │   │       └── page.tsx
│   │   └── tsconfig.json
│   └── frontend/
│       ├── package.json
│       ├── next-env.d.ts
│       ├── next.config.js
│       ├── src/
│       │   └── app/
│       │       └── page.tsx
│       └── tsconfig.json
└── packages/
    ├── scripts/
    │   ├── package.json
    │   ├── src/
    │   │   └── index.tsx
    │   └── tsconfig.json
    ├── shared/
    │   ├── package.json
    │   ├── src/
    │   │   ├── __tests__/
    │   │   │   ├── sum.test.ts
    │   │   │   └── tsconfig.json
    │   │   ├── index.ts
    │   │   └── sum.ts
    │   └── tsconfig.json
    ├── ui/
    │   ├── package.json
    │   ├── src/
    │   │   └── index.tsx
    │   └── tsconfig.json
    └── utils/
        ├── package.json
        ├── src/
        │   └── index.tsx
        └── tsconfig.json
```

运行 `turbo prune frontend` 在 `out` 目录中为 `frontend` 应用程序生成修剪的工作空间：

```
├── package.json
├── pnpm-lock.yaml (partial)
├── apps/
│   └── frontend/
│       ├── package.json
│       ├── next-env.d.ts
│       ├── next.config.js
│       ├── src/
│       │   └── app/
│       │       └── page.tsx
│       └── tsconfig.json
└── packages/
    ├── shared/
    │   ├── package.json
    │   ├── src/
    │   │   ├── __tests__/
    │   │   │   ├── sum.test.ts
    │   │   │   └── tsconfig.json
    │   │   ├── index.ts
    │   │   └── sum.ts
    │   └── tsconfig.json
    └── ui/
        ├── package.json
        ├── src/
        │   └── index.tsx
        └── tsconfig.json
```

### 选项

#### `--docker`

默认值：`false`。

修改输出目录以便更容易与 [Docker 最佳实践和层缓存](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/) 一起使用。目录将包含：

- 名为 `json` 的文件夹，包含修剪工作空间的 `package.json` 文件。
- 名为 `full` 的文件夹，包含构建目标所需的内部包的修剪工作空间的完整源代码。
- 包含构建目标所需的原始锁文件子集的修剪锁文件。

使用上面的相同示例，运行 `turbo prune frontend --docker` 将生成以下内容：

```
├── pnpm-lock.yaml (partial)
├── full/
│   ├── package.json (from repo root)
│   ├── apps/
│   │   └── frontend/
│   │       ├── package.json
│   │       ├── next-env.d.ts
│   │       ├── next.config.js
│   │       ├── src/
│   │       │   └── app/
│   │       │       └── page.tsx
│   │       └── tsconfig.json
│   └── packages/
│       ├── shared/
│       │   ├── package.json
│       │   ├── src/
│       │   │   ├── __tests__/
│       │   │   │   ├── sum.test.ts
│       │   │   │   └── tsconfig.json
│       │   │   ├── index.ts
│       │   │   └── sum.ts
│       │   └── tsconfig.json
│       └── ui/
│           ├── package.json
│           ├── src/
│           │   └── index.tsx
│           └── tsconfig.json
└── json/
    ├── package.json (from repo root)
    ├── apps/
    │   └── frontend/
    │       └── package.json
    └── packages/
        ├── ui/
        │   └── package.json
        └── shared/
            └── package.json
```

#### `--out-dir <path>`

默认值：`./out`。

自定义生成修剪输出的目录。

#### `--use-gitignore[=<bool>]`

默认值：`true`

在将文件复制到输出目录时遵守 `.gitignore` 文件。

### 与 `pnpm deploy` 的比较

虽然 `turbo prune` 和 [`pnpm deploy`](https://pnpm.io/cli/deploy) 都用于在 monorepo 中隔离包，但它们服务于不同的目的并产生不同的输出。

`turbo prune` 生成部分 monorepo，而 `pnpm deploy` 生成仅包含目标包内容的目录。

`pnpm deploy` 生成的目录具有自包含的 `node_modules`，其中包含硬链接的内部依赖项。
这产生了一个可移植的包，可以直接复制到服务器并使用，无需额外步骤。
仓库结构不会保留，因为重点是生成独立的可部署包。
